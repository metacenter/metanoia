// file: drm.c
// vim: tabstop=4 expandtab colorcolumn=81 list

#include "drm.h"
#include "utils/log.h"
#include "renderer-gl.h"

#include <errno.h>
#include <string.h>

#include <xf86drm.h>
#include <xf86drmMode.h>
#include <sys/mman.h>

#include <GLES2/gl2.h>
#include <GLES2/gl2ext.h>
#include <EGL/egl.h>
#include <gbm.h>

#include "utils/dbus.h"
#include <malloc.h>
#include <libudev.h>
#include <unistd.h>
#include <string.h>
#include <linux/input.h>

//#include "esTransform.c" // TODO: remove
//#include "kmscube.c"

//------------------------------------------------------------------------------

static const char* scModuleName[] = {
        "i915", "radeon", "nouveau", "vmwgfx", "omapdrm", "exynos", "msm", NULL
    };

static const char* scConnectorTypeName[] = {
        "NONE", "VGA", "DVII", "DVID", "DVIA", "Composite", "SVIDEO", "LVDS",
        "Component", "9PinDIN", "DisplayPort", "HDMIA", "HDMIB", NULL
    };

static const char* scConnectorStateName[] = {
        "NONE", "connected", "disconnected", "Unknown", NULL
    };


	struct gbm_device *gbm_dev;
	struct gbm_surface *gbm_surface;

static struct {
	EGLDisplay display;
	EGLConfig config;
	EGLContext context;
	EGLSurface surface;
	GLuint program;
	GLint modelviewmatrix, modelviewprojectionmatrix, normalmatrix;
	GLuint vbo;
	GLuint positionsoffset, colorsoffset, normalsoffset;
} gl;



//------------------------------------------------------------------------------


void print_log(GLuint object)
{
  GLint log_length = 0;
  if (glIsShader(object))
    glGetShaderiv(object, GL_INFO_LOG_LENGTH, &log_length);
  else if (glIsProgram(object))
    glGetProgramiv(object, GL_INFO_LOG_LENGTH, &log_length);
  else {
    LOG_ERROR("printlog: Not a shader or a program");
    return;
  }

  char* log = (char*)malloc(log_length);

  if (glIsShader(object))
    glGetShaderInfoLog(object, log_length, NULL, log);
  else if (glIsProgram(object))
    glGetProgramInfoLog(object, log_length, NULL, log);

  LOG_ERROR("PL: %s", log);
  free(log);
}

//------------------------------------------------------------------------------

int create_dumb_buffer(int drm_fd,
                       drmModeModeInfo *mode,
                       uint32_t* fb_id)
{
    int result = 0;
    uint8_t* map;
    struct drm_mode_create_dumb carg;
    struct drm_mode_destroy_dumb darg;
    struct drm_mode_map_dumb marg;

    // Create dumb buffer
    LOG_DEBUG("E: %d", errno);
    memset(&carg, 0, sizeof(carg));
    carg.width  = mode->hdisplay;
    carg.height = mode->vdisplay;
    carg.bpp = 32;

    LOG_DEBUG("S: %d*%d=%d", carg.width, carg.height, carg.width*carg.height);

    result = drmIoctl(drm_fd, DRM_IOCTL_MODE_CREATE_DUMB, &carg);
    if (result < 0) {
        LOG_ERROR("Cannot create dumb buffer (%d): %s", errno, strerror(errno));
        return -errno;
    }
    LOG_DEBUG("H: %d, %d", carg.size, carg.handle);

    // Create framebuffer object for the dumb-buffer
    result = drmModeAddFB(drm_fd, carg.width, carg.height, 24,
                          carg.bpp, carg.pitch, carg.handle, fb_id);
    if (result) {
        LOG_ERROR("Cannot create framebuffer (%d): %s", errno, strerror(errno));
        result = -errno;
        goto clear_db;
    }

    LOG_DEBUG("H: %d, %d", carg.size, carg.handle);
    // Prepare buffer for memory mapping
    memset(&marg, 0, sizeof(marg));
    marg.handle = carg.handle;
    result = drmIoctl(drm_fd, DRM_IOCTL_MODE_MAP_DUMB, &marg);
    if (result) {
        LOG_ERROR("Cannot map dumb buffer (%d): %s", errno, strerror(errno));
        result = -errno;
        goto clear_fb;
    }

    LOG_DEBUG("H: %d %d", carg.size, marg.offset);
    LOG_DEBUG("E: %d", errno);
    // Perform actual memory mapping
    map = mmap(0, carg.size, PROT_READ | PROT_WRITE,
               MAP_SHARED, drm_fd, marg.offset);

    LOG_DEBUG("E: %d", errno);
    if (map == MAP_FAILED) {
        LOG_ERROR("Cannot mmap dumb buffer (%d): %s", errno, strerror(errno));
        result = -errno;
        goto clear_fb;
    }

clear_fb:
    drmModeRmFB(drm_fd, *fb_id);

clear_db:
    memset(&darg, 0, sizeof(darg));
    darg.handle = carg.handle;
    drmIoctl(drm_fd, DRM_IOCTL_MODE_DESTROY_DUMB, &darg);

    return result;
}

//------------------------------------------------------------------------------

void glerror(char* str)
{
    GLint error = glGetError();
    LOG_ERROR("glError (0x%x) after %s", error, str);
}

//------------------------------------------------------------------------------

static int init_gl1(int hdisplay, int vdisplay)
{
	EGLint major, minor, n;
	GLuint vertex_shader, fragment_shader;
	GLint ret;

	/*static const GLfloat vVertices[] = {
			// front
			-1.0f, -1.0f, +1.0f, // point blue
			+1.0f, -1.0f, +1.0f, // point magenta
			-1.0f, +1.0f, +1.0f, // point cyan
			+1.0f, +1.0f, +1.0f, // point white
			// back
			+1.0f, -1.0f, -1.0f, // point red
			-1.0f, -1.0f, -1.0f, // point black
			+1.0f, +1.0f, -1.0f, // point yellow
			-1.0f, +1.0f, -1.0f, // point green
			// right
			+1.0f, -1.0f, +1.0f, // point magenta
			+1.0f, -1.0f, -1.0f, // point red
			+1.0f, +1.0f, +1.0f, // point white
			+1.0f, +1.0f, -1.0f, // point yellow
			// left
			-1.0f, -1.0f, -1.0f, // point black
			-1.0f, -1.0f, +1.0f, // point blue
			-1.0f, +1.0f, -1.0f, // point green
			-1.0f, +1.0f, +1.0f, // point cyan
			// top
			-1.0f, +1.0f, +1.0f, // point cyan
			+1.0f, +1.0f, +1.0f, // point white
			-1.0f, +1.0f, -1.0f, // point green
			+1.0f, +1.0f, -1.0f, // point yellow
			// bottom
			-1.0f, -1.0f, -1.0f, // point black
			+1.0f, -1.0f, -1.0f, // point red
			-1.0f, -1.0f, +1.0f, // point blue
			+1.0f, -1.0f, +1.0f  // point magenta
	};

	static const GLfloat vColors[] = {
			// front
			0.0f,  0.0f,  1.0f, // blue
			1.0f,  0.0f,  1.0f, // magenta
			0.0f,  1.0f,  1.0f, // cyan
			1.0f,  1.0f,  1.0f, // white
			// back
			1.0f,  0.0f,  0.0f, // red
			0.0f,  0.0f,  0.0f, // black
			1.0f,  1.0f,  0.0f, // yellow
			0.0f,  1.0f,  0.0f, // green
			// right
			1.0f,  0.0f,  1.0f, // magenta
			1.0f,  0.0f,  0.0f, // red
			1.0f,  1.0f,  1.0f, // white
			1.0f,  1.0f,  0.0f, // yellow
			// left
			0.0f,  0.0f,  0.0f, // black
			0.0f,  0.0f,  1.0f, // blue
			0.0f,  1.0f,  0.0f, // green
			0.0f,  1.0f,  1.0f, // cyan
			// top
			0.0f,  1.0f,  1.0f, // cyan
			1.0f,  1.0f,  1.0f, // white
			0.0f,  1.0f,  0.0f, // green
			1.0f,  1.0f,  0.0f, // yellow
			// bottom
			0.0f,  0.0f,  0.0f, // black
			1.0f,  0.0f,  0.0f, // red
			0.0f,  0.0f,  1.0f, // blue
			1.0f,  0.0f,  1.0f  // magenta
	};

	static const GLfloat vNormals[] = {
			// front
			+0.0f, +0.0f, +1.0f, // forward
			+0.0f, +0.0f, +1.0f, // forward
			+0.0f, +0.0f, +1.0f, // forward
			+0.0f, +0.0f, +1.0f, // forward
			// back
			+0.0f, +0.0f, -1.0f, // backbard
			+0.0f, +0.0f, -1.0f, // backbard
			+0.0f, +0.0f, -1.0f, // backbard
			+0.0f, +0.0f, -1.0f, // backbard
			// right
			+1.0f, +0.0f, +0.0f, // right
			+1.0f, +0.0f, +0.0f, // right
			+1.0f, +0.0f, +0.0f, // right
			+1.0f, +0.0f, +0.0f, // right
			// left
			-1.0f, +0.0f, +0.0f, // left
			-1.0f, +0.0f, +0.0f, // left
			-1.0f, +0.0f, +0.0f, // left
			-1.0f, +0.0f, +0.0f, // left
			// top
			+0.0f, +1.0f, +0.0f, // up
			+0.0f, +1.0f, +0.0f, // up
			+0.0f, +1.0f, +0.0f, // up
			+0.0f, +1.0f, +0.0f, // up
			// bottom
			+0.0f, -1.0f, +0.0f, // down
			+0.0f, -1.0f, +0.0f, // down
			+0.0f, -1.0f, +0.0f, // down
			+0.0f, -1.0f, +0.0f  // down
	};*/

	static const EGLint context_attribs[] = {
		EGL_CONTEXT_CLIENT_VERSION, 2,
		EGL_NONE
	};

	static const EGLint config_attribs[] = {
		EGL_SURFACE_TYPE, EGL_WINDOW_BIT,
		EGL_RED_SIZE, 1,
		EGL_GREEN_SIZE, 1,
		EGL_BLUE_SIZE, 1,
		EGL_ALPHA_SIZE, 0,
		EGL_RENDERABLE_TYPE, EGL_OPENGL_ES2_BIT,
		EGL_NONE
	};

	/*static const char *vertex_shader_source =
			"uniform mat4 modelviewMatrix;      \n"
			"uniform mat4 modelviewprojectionMatrix;\n"
			"uniform mat3 normalMatrix;         \n"
			"                                   \n"
			"attribute vec4 in_position;        \n"
			"attribute vec3 in_normal;          \n"
			"attribute vec4 in_color;           \n"
			"\n"
			"vec4 lightSource = vec4(2.0, 2.0, 20.0, 0.0);\n"
			"                                   \n"
			"varying vec4 vVaryingColor;        \n"
			"                                   \n"
			"void main()                        \n"
			"{                                  \n"
			"    gl_Position = modelviewprojectionMatrix * in_position;\n"
			"    vec3 vEyeNormal = normalMatrix * in_normal;\n"
			"    vec4 vPosition4 = modelviewMatrix * in_position;\n"
			"    vec3 vPosition3 = vPosition4.xyz / vPosition4.w;\n"
			"    vec3 vLightDir = normalize(lightSource.xyz - vPosition3);\n"
			"    float diff = max(0.0, dot(vEyeNormal, vLightDir));\n"
			"    vVaryingColor = vec4(diff * in_color.rgb, 1.0);\n"
			"}                                  \n";

	static const char *fragment_shader_source =
			"precision mediump float;           \n"
			"                                   \n"
			"varying vec4 vVaryingColor;        \n"
			"                                   \n"
			"void main()                        \n"
			"{                                  \n"
			"    gl_FragColor = vVaryingColor;  \n"
			"}                                  \n";
*/
	gl.display = eglGetDisplay((EGLNativeDisplayType) gbm_dev);

	if (!eglInitialize(gl.display, &major, &minor)) {
		LOG_DEBUG("failed to initialize\n");
		return -1;
	}

	LOG_DEBUG("Using display %p with EGL version %d.%d\n",
			gl.display, major, minor);

	LOG_DEBUG("EGL Version '%s'", eglQueryString(gl.display, EGL_VERSION));
	LOG_DEBUG("EGL Vendor '%s'", eglQueryString(gl.display, EGL_VENDOR));

	if (!eglBindAPI(EGL_OPENGL_ES_API)) {
		LOG_DEBUG("failed to bind api EGL_OPENGL_ES_API\n");
		return -1;
	}

	if (!eglChooseConfig(gl.display, config_attribs, &gl.config, 1, &n) || n != 1) {
		LOG_DEBUG("failed to choose config: %d\n", n);
		return -1;
	}

	gl.context = eglCreateContext(gl.display, gl.config,
			EGL_NO_CONTEXT, context_attribs);
	if (gl.context == NULL) {
		LOG_DEBUG("failed to create context\n");
		return -1;
	}

	gl.surface = eglCreateWindowSurface(gl.display, gl.config,
                          (EGLNativeWindowType) gbm_surface, NULL);
	if (gl.surface == EGL_NO_SURFACE) {
		LOG_DEBUG("failed to create egl surface\n");
		return -1;
	}

	/* connect the context to the surface */
	eglMakeCurrent(gl.display, gl.surface, gl.surface, gl.context);


	/*vertex_shader = glCreateShader(GL_VERTEX_SHADER);

	glShaderSource(vertex_shader, 1, &vertex_shader_source, NULL);
	glCompileShader(vertex_shader);

	glGetShaderiv(vertex_shader, GL_COMPILE_STATUS, &ret);
	if (!ret) {
		char *log;

		LOG_DEBUG("vertex shader compilation failed!:\n");
		glGetShaderiv(vertex_shader, GL_INFO_LOG_LENGTH, &ret);
		if (ret > 1) {
			log = malloc(ret);
			glGetShaderInfoLog(vertex_shader, ret, NULL, log);
			LOG_DEBUG("%s", log);
		}

		return -1;
	}

	fragment_shader = glCreateShader(GL_FRAGMENT_SHADER);

	glShaderSource(fragment_shader, 1, &fragment_shader_source, NULL);
	glCompileShader(fragment_shader);

	glGetShaderiv(fragment_shader, GL_COMPILE_STATUS, &ret);
	if (!ret) {
		char *log;

		LOG_DEBUG("fragment shader compilation failed!:\n");
		glGetShaderiv(fragment_shader, GL_INFO_LOG_LENGTH, &ret);

		if (ret > 1) {
			log = malloc(ret);
			glGetShaderInfoLog(fragment_shader, ret, NULL, log);
			LOG_DEBUG("%s", log);
		}

		return -1;
	}

	gl.program = glCreateProgram();

	glAttachShader(gl.program, vertex_shader);
	glAttachShader(gl.program, fragment_shader);

	glBindAttribLocation(gl.program, 0, "in_position");
	glBindAttribLocation(gl.program, 1, "in_normal");
	glBindAttribLocation(gl.program, 2, "in_color");

	glLinkProgram(gl.program);

	glGetProgramiv(gl.program, GL_LINK_STATUS, &ret);
	if (!ret) {
		char *log;

		LOG_DEBUG("program linking failed!:\n");
		glGetProgramiv(gl.program, GL_INFO_LOG_LENGTH, &ret);

		if (ret > 1) {
			log = malloc(ret);
			glGetProgramInfoLog(gl.program, ret, NULL, log);
			LOG_DEBUG("%s", log);
		}

		return -1;
	}

	glUseProgram(gl.program);*/

	/*gl.modelviewmatrix = glGetUniformLocation(gl.program, "modelviewMatrix");
	gl.modelviewprojectionmatrix = glGetUniformLocation(gl.program, "modelviewprojectionMatrix");
	gl.normalmatrix = glGetUniformLocation(gl.program, "normalMatrix");*/

	glViewport(0, 0, hdisplay, vdisplay);
	glEnable(GL_CULL_FACE);

	/*gl.positionsoffset = 0;
	gl.colorsoffset = sizeof(vVertices);
	gl.normalsoffset = sizeof(vVertices) + sizeof(vColors);
	glGenBuffers(1, &gl.vbo);
	glBindBuffer(GL_ARRAY_BUFFER, gl.vbo);
	glBufferData(GL_ARRAY_BUFFER, sizeof(vVertices) + sizeof(vColors) + sizeof(vNormals), 0, GL_STATIC_DRAW);
	glBufferSubData(GL_ARRAY_BUFFER, gl.positionsoffset, sizeof(vVertices), &vVertices[0]);
	glBufferSubData(GL_ARRAY_BUFFER, gl.colorsoffset, sizeof(vColors), &vColors[0]);
	glBufferSubData(GL_ARRAY_BUFFER, gl.normalsoffset, sizeof(vNormals), &vNormals[0]);
	glVertexAttribPointer(0, 3, GL_FLOAT, GL_FALSE, 0, (const GLvoid*)gl.positionsoffset);
	glEnableVertexAttribArray(0);
	glVertexAttribPointer(1, 3, GL_FLOAT, GL_FALSE, 0, (const GLvoid*)gl.normalsoffset);
	glEnableVertexAttribArray(1);
	glVertexAttribPointer(2, 3, GL_FLOAT, GL_FALSE, 0, (const GLvoid*)gl.colorsoffset);
	glEnableVertexAttribArray(2);*/

	return 0;
}












int create_gbm(int drm_fd,
               drmModeConnector* connector,
               uint32_t crtc_id,
               drmModeModeInfo *mode)
{
    int ret;
    uint32_t fb_id;
    struct gbm_bo* bo;
    LOG_DEBUG("Creating GBM");

	gbm_dev = gbm_create_device(drm_fd);

    LOG_DEBUG("1 %d", (int) mode);
	gbm_surface = gbm_surface_create(gbm_dev,
			mode->hdisplay, mode->vdisplay,
			GBM_FORMAT_XRGB8888,
			GBM_BO_USE_SCANOUT | GBM_BO_USE_RENDERING);
    LOG_DEBUG("2");
	if (!gbm_surface) {
		LOG_DEBUG("failed to create gbm surface\n");
		return -1;
	}




	ret = init_gl1(mode->hdisplay, mode->vdisplay);
	if (ret) {
		LOG_DEBUG("failed to initialize EGL 1\n");
		return ret;
	}
	/* clear the color buffer */
	glClearColor(0.0, 0.25, 0.50, 1.0);
	glClear(GL_COLOR_BUFFER_BIT);


	eglSwapBuffers(gl.display, gl.surface);

	bo = gbm_surface_lock_front_buffer(gbm_surface);
    if (!bo) {
        LOG_ERROR("Could not lock GBM front buffer!");
        return -1;
    }


	/*ret = init_gl2(mode->hdisplay, mode->vdisplay);
	if (ret) {
		LOG_DEBUG("failed to initialize EGL 2\n");
		return ret;
	}
	glClearColor(0.0, 0.25, 0.50, 1.0);
	glClear(GL_COLOR_BUFFER_BIT);*/


    LOG_DEBUG("5");
	uint32_t width, height, stride, handle;
	width = gbm_bo_get_width(bo);
	height = gbm_bo_get_height(bo);
	stride = gbm_bo_get_stride(bo);
	handle = gbm_bo_get_handle(bo).u32;

    LOG_DEBUG("6");
	ret = drmModeAddFB(drm_fd, width, height, 24, 32,
                           stride, handle, &fb_id);
	if (ret) {
		LOG_DEBUG("failed to create fb: %s\n", strerror(errno));
		return -1;
	}

    // set mode
    ret = drmModeSetCrtc(drm_fd, crtc_id, fb_id, 0, 0,
                    &connector->connector_id, 1, &connector->modes[0]);
    if (ret) {
        LOG_ERROR("failed to set mode: %s\n", strerror(errno));
        return -1;
    }







    return 1;
}

//------------------------------------------------------------------------------

int update_device(int drm_fd,
                  drmModeRes* resources,
                  drmModeConnector* connector)
{
    int i, result = 0;
    drmModeEncoder *encoder = NULL;

    LOG_INFO2("Updating connector %u", connector->connector_id);

    // Check if there is at least one valid mode
    if (connector->count_modes == 0) {
        LOG_ERROR("No valid mode!");
        return -EFAULT;
    }

    // Find encoder
    for (i = 0; i < resources->count_encoders; ++i) {
        encoder = drmModeGetEncoder(drm_fd, resources->encoders[i]);
        if (encoder && encoder->encoder_id == connector->encoder_id) {
            break;
        }
        drmModeFreeEncoder(encoder);
        encoder = NULL;
    }

    if (!encoder) {
        LOG_ERROR("No encoder!");
        return -EFAULT;
    }

    result = create_gbm(drm_fd, connector, encoder->crtc_id,
                        &connector->modes[0]);
    if (result < 0) {
        //result = create_dumb_buffer(drm_fd, &connector->modes[0], &fb_id);
        //if (result) {
            LOG_ERROR("DRM failed!");
            return -1;
        //}
    }

    return result;
}

//------------------------------------------------------------------------------

int aura_drm_update_devices(Output** outputs, int* num)
{
    //kmscube_main(); // TODO: remove

    drmModeRes* resources = NULL;
    drmModeConnector* connector = NULL;
    int fd, i;

    LOG_INFO1("Updating DRM devices");

    // Find and open DRM device
    for (i = 0; i < sizeof(scModuleName); ++i) {
        fd = drmOpen(scModuleName[i], NULL);
        if (fd > 0) {
            break;
        }
    }
    if (fd > 0) {
        LOG_INFO1("Found DRM device (%s)", scModuleName[i]);
    } else {
        LOG_ERROR("Could not open DRM device!");
        return -1;
    }

/*char node[] = "/dev/dri/card0";

struct stat st;
int r = stat(node, &st);
if (r >= 0) {
    fd = aura_dbus_session_take_device(major(st.st_rdev), minor(st.st_rdev));
    LOG_DEBUG("FD: %d", fd);
} else {
    LOG_ERROR("NO STAT");
}*/

    uint64_t has_dumb;
    if (drmGetCap(fd, DRM_CAP_DUMB_BUFFER, &has_dumb) < 0 || !has_dumb) {
        LOG_ERROR("drm device does not support dumb buffers");
        close(fd);
        return -1;
    }

int ret = drmSetMaster(fd);
LOG_DEBUG("MASTER: %d", ret);
if (ret == -1) {
    LOG_ERROR("Set Master: %s", strerror(errno));
}

    // Get resources
    resources = drmModeGetResources(fd);
    if (!resources) {
        LOG_ERROR("drmModeGetResources failed: %s", strerror(errno));
        return -1;
    }

    // Find a connected connector
    for (i = 0; i < resources->count_connectors; ++i) {
        connector = drmModeGetConnector(fd, resources->connectors[i]);
        if (connector) {
            LOG_INFO2("Connector: %s (%s)",
                       scConnectorTypeName[connector->connector_type],
                       scConnectorStateName[connector->connection]);
            // If connector is connected - update device
            if (connector->connection == DRM_MODE_CONNECTED) {
                update_device(fd, resources, connector);
            }
            drmModeFreeConnector(connector);
        }
        connector = NULL;
    }

    // TODO: put malloc elsewhere
    *outputs = malloc(sizeof(Output));
    (*outputs)->width = 1366;
    (*outputs)->height = 768;
    (*outputs)->renderer = aura_renderer_gl_create();
    *num = 1;

    // Free memory
    drmModeFreeResources(resources);

    return 1;
}

